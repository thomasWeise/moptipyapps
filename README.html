<!doctype html><html data-content_root=./ lang=en><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0"name=viewport><meta content="width=device-width,initial-scale=1"name=viewport><title>1. Introduction — moptipyapps 0.8.68 documentation</title><link href="/moptipyapps/_static/pygments.css?v=b86133f3"rel=stylesheet><link href="/moptipyapps/_static/bizstyle.css?v=5283bb3d"rel=stylesheet><script src="/moptipyapps/_static/documentation_options.js?v=f8800668"></script><script src="/moptipyapps/_static/doctools.js?v=9bcbadda"></script><script src="/moptipyapps/_static/sphinx_highlight.js?v=dc90522c"></script><script src=_static/bizstyle.js></script><link href=https://thomasweise.github.io/moptipyapps/README.html rel=canonical><link href=genindex.html rel=index title=Index><link href=search.html rel=search title=Search><meta content="width=device-width,initial-scale=1.0"name=viewport><body><div aria-label=Related class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="General Index"accesskey=I href=genindex.html>index</a><li class=right><a title="Python Module Index"href=py-modindex.html>modules</a> |<li class="nav-item nav-item-0"><a href=index.html>moptipyapps 0.8.68 documentation</a> »<li class="nav-item nav-item-this"><a href>1. Introduction</a></ul></div><div class=document><div class=documentwrapper><div class=bodywrapper><div class=body role=main><p><a class="reference external"href=https://github.com/thomasWeise/moptipy/actions/workflows/build.yml><img alt=build src=https://github.com/thomasWeise/moptipyapps/actions/workflows/build.yml/badge.svg></a> <a class="reference external"href=https://pypi.org/project/moptipyapps><img alt="pypi version"src=https://img.shields.io/pypi/v/moptipyapps></a> <a class="reference external"href=https://pypistats.org/packages/moptipyapps><img alt="pypi downloads"src=https://img.shields.io/pypi/dw/moptipyapps.svg></a> <a class="reference external"href=https://thomasweise.github.io/moptipyapps/tc/index.html><img alt="coverage report"src=https://thomasweise.github.io/moptipyapps/tc/badge.svg></a><section id=introduction><h1>1. Introduction<a title="Link to this heading"class=headerlink href=#introduction>¶</a></h1><p><a class="reference external"href=https://thomasweise.github.io/moptipy/><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> is a library with implementations of metaheuristic optimization methods in Python 3.12 that also offers an environment for replicable experiments (<a class="reference external"href=https://thomasweise.github.io/moptipy/_static/moptipy_flyer.pdf><code class="docutils literal notranslate"><span class=pre>flyer</span></code></a>). <a class="reference external"href=./><code class="docutils literal notranslate"><span class=pre>moptipyapps</span></code></a> is a collection of applications and experiments based on <code class="docutils literal notranslate"><span class=pre>moptipy</span></code>.</section><section id=installation><h1>2. Installation<a title="Link to this heading"class=headerlink href=#installation>¶</a></h1><p>In order to use this package and to, e.g., run the example codes, you need to first install it using <a class="reference external"href=https://pypi.org/project/pip/><code class="docutils literal notranslate"><span class=pre>pip</span></code></a> or some other tool that can install packages from <a class="reference external"href=https://pypi.org>PyPi</a>. You can install the newest version of this library from <a class="reference external"href=https://pypi.org/project/moptipyapps/>PyPi</a> using <a class="reference external"href=https://pypi.org/project/pip/><code class="docutils literal notranslate"><span class=pre>pip</span></code></a> by doing<div class="highlight-shell notranslate"><div class=highlight><pre><span></span>pip<span class=w> </span>install<span class=w> </span>moptipyapps
</pre></div></div><p>This will install the latest official release of our package as well as <a class="reference external"href=./requirements_txt.html>all dependencies</a>. If you want to install the latest source code version from GitHub (which may not yet be officially released), you can do<div class="highlight-shell notranslate"><div class=highlight><pre><span></span>pip<span class=w> </span>install<span class=w> </span>git+https://github.com/thomasWeise/moptipyapps.git
</pre></div></div><p>If you want to install the latest source code version from GitHub (which may not yet be officially released) and you have set up a private/public key for GitHub, you can also do:<div class="highlight-shell notranslate"><div class=highlight><pre><span></span>git<span class=w> </span>clone<span class=w> </span>ssh://git@github.com/thomasWeise/moptipyapps
pip<span class=w> </span>install<span class=w> </span>moptipyapps
</pre></div></div><p>This may sometimes work better if you are having trouble reaching GitHub via <code class="docutils literal notranslate"><span class=pre>https</span></code> or <code class="docutils literal notranslate"><span class=pre>http</span></code>.<p>You can also clone the repository and then run a <a class="reference external"href=./Makefile.html><code class="docutils literal notranslate"><span class=pre>make</span></code> build</a>, which will automatically install all dependencies, run all the tests, and then install the package on your system, too. This will work only on Linux, though. It also installs the <a class="reference external"href=./requirements-dev_txt.html>dependencies for building</a>, which include, e.g., those for <a class="reference external"href=#unit-tests-and-static-analysis>unit testing and static analysis</a>. If this build completes successful, you can be sure that <a class="reference external"href=./><code class="docutils literal notranslate"><span class=pre>moptipyapps</span></code></a> will work properly on your machine.<p>All dependencies for using and running <code class="docutils literal notranslate"><span class=pre>moptipyapps</span></code> are listed at <a class="reference external"href=./requirements_txt.html>here</a>. The additional dependencies for a <a class="reference external"href=./Makefile.html>full <code class="docutils literal notranslate"><span class=pre>make</span></code> build</a>, including unit tests, static analysis, and the generation of documentation are listed <a class="reference external"href=./requirements-dev_txt.html>here</a>.</section><section id=applications><h1>3. Applications<a title="Link to this heading"class=headerlink href=#applications>¶</a></h1><p>Here we list the applications of <a class="reference external"href=https://thomasweise.github.io/moptipy><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a>. Step by step, we will add more and more interesting optimization problems. For each problem, we provide means to load the problem instances and a basic infrastructure to construct optimization algorithms for solving them.<section id=two-dimensional-bin-packing-problem><h2>3.1. Two-Dimensional Bin Packing Problem<a title="Link to this heading"class=headerlink href=#two-dimensional-bin-packing-problem>¶</a></h2><p>In the package <a class="reference external"href=./moptipyapps.binpacking2d.html#module-moptipyapps.binpacking2d><code class="docutils literal notranslate"><span class=pre>moptipyapps.binpacking2d</span></code></a>, we provide tools for experimenting and playing around with the two-dimensional bin packing problem. Bin packing is a classical domain from Operations Research. The goal is to pack objects into containers, the so-called bins. We address <a class="reference external"href=./moptipyapps.binpacking2d.html#module-moptipyapps.binpacking2d>two-dimensional rectangular bin packing</a>. We provide the bin packing <a class="reference external"href=./moptipyapps.binpacking2d.html#module-moptipyapps.binpacking2d.instance>instances</a> from <a class="reference external"href=https://site.unibo.it/operations-research/en/research/2dpacklib>2DPackLib</a> as <a class="reference external"href=./moptipyapps.binpacking2d.html#moptipyapps.binpacking2d.instance.Instance.from_resource>resources</a> together with <a class="reference external"href=./moptipyapps.binpacking2d.html#module-moptipyapps.binpacking2d>this package</a> as well as the four non-trivial “<a class="reference external"href=https://hdl.handle.net/11245/1.545914>Almost Squares in Almost Squares</a>” instances. Each such instances defines a set of <code class="docutils literal notranslate"><span class=pre>n_different_items</span></code> objects <code class="docutils literal notranslate"><span class=pre>Oi</span></code> with <code class="docutils literal notranslate"><span class=pre>i</span></code> from <code class="docutils literal notranslate"><span class=pre>1..n_different_objects</span></code>. Each object <code class="docutils literal notranslate"><span class=pre>Oi</span></code> is a rectangle with a given width and height. The object occur is a given multiplicity <code class="docutils literal notranslate"><span class=pre>repetitions(O_i)</span></code>, i.e., either only once or multiple times. The bins are rectangles with a given width and height too. The goal of tackling such an instance is to package all the objects into as few as possible bins. The objects therefore may be rotated by 90 degrees.<p>We address this problem by representing a packing as a <a class="reference external"href=https://thomasweise.github.io/moptipy/moptipy.spaces.html#module-moptipy.spaces.signed_permutations>signed permutation with repetitions</a> of the numbers <code class="docutils literal notranslate"><span class=pre>1..n_different_objects</span></code>, where the number <code class="docutils literal notranslate"><span class=pre>i</span></code> occurs <code class="docutils literal notranslate"><span class=pre>repetitions(O_i)</span></code> times. If an object is to be placed in a rotated way, this is denoted by using <code class="docutils literal notranslate"><span class=pre>-i</span></code> instead of <code class="docutils literal notranslate"><span class=pre>i</span></code>. Such permutations are processed from beginning to end, placing the objects into bins as they come according to some heuristic encoding. We provide two variants of the Improved Bottom Left encoding. <a class="reference external"href=./moptipyapps.binpacking2d.encodings.html#module-moptipyapps.binpacking2d.encodings.ibl_encoding_1>The first one</a> closes bins as soon as one object cannot be placed into them. <a class="reference external"href=./moptipyapps.binpacking2d.encodings.html#module-moptipyapps.binpacking2d.encodings.ibl_encoding_2>The second one</a> tries to put each object in the earliest possible bin. While the former one is faster, the latter one leads to better packings.<p>We can then apply a black-box metaheuristic to search in the space of these signed permutations with repetitions. The objective function would be some measure consistent with the goal of minimizing the number of bins used.<p><em>Examples:</em><ul class=simple><li><p><a class="reference external"href=./examples/binpacking2d_plot_py.html>plot a packing chart</a><li><p><a class="reference external"href=./examples/binpacking2d_rls_py.html>apply a randomized local search to one 2D bin packing instance</a><li><p><a class="reference external"href=./examples/binpacking2d_timing_py.html>measure the runtime of the different encodings for the 2D bin packing problem</a></ul><p>Important work on this code has been contributed by Mr. Rui ZHAO (赵睿), <a class="reference external"href=mailto:zr1329142665%40163.com>zr1329142665<span>@</span>163<span>.</span>com</a>, a Master’s student at the Institute of Applied Optimization (应用优化研究所) of the School of Artificial Intelligence and Big Data (人工智能与大数据学院) at Hefei University (合肥学院) in Hefei, Anhui, China (中国安徽省合肥市) under the supervision of Prof. Dr. Thomas Weise (汤卫思教授), who then refined the implementations.</section><section id=the-traveling-salesperson-problem-tsp><h2>3.2. The Traveling Salesperson Problem (TSP)<a title="Link to this heading"class=headerlink href=#the-traveling-salesperson-problem-tsp>¶</a></h2><p>In the package <a class="reference external"href=./moptipyapps.tsp.html#module-moptipyapps.tsp><code class="docutils literal notranslate"><span class=pre>moptipyapps.tsp</span></code></a>, we provide tools to run experiments and play around with the Traveling Salesperson Problem (TSP) . A TSP instance is defined as a fully-connected graph with <code class="docutils literal notranslate"><span class=pre>n_cities</span></code> nodes. Each edge in the graph has a weight, which identifies the distance between the nodes. The goal is to find the <em>shortest</em> tour that visits every single node in the graph exactly once and then returns back to its starting node. Then nodes are usually called cities. A tour can be represented in path representation, which means that it is stored as a permutation of the numbers <code class="docutils literal notranslate"><span class=pre>0</span></code> to <code class="docutils literal notranslate"><span class=pre>n_cities-1</span></code>. The number at index <code class="docutils literal notranslate"><span class=pre>k</span></code> identifies that <code class="docutils literal notranslate"><span class=pre>k</span></code>-th city to visit. So the first number in the permutation identifies the first city, the second number the second city, and so on. The length of the tour can be computed by summing up the distances from the <code class="docutils literal notranslate"><span class=pre>k</span></code>-th city to the <code class="docutils literal notranslate"><span class=pre>k+1</span></code>-st city, for <code class="docutils literal notranslate"><span class=pre>k</span></code> in <code class="docutils literal notranslate"><span class=pre>0..n_cities-2</span></code> and then adding the distance from the last city to the first city.<p>We use the TSP instances from <a class="reference external"href=http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/>TSPLib</a>, the maybe most important benchmark set for the TSP. 110 of these instances are included as resources in this package.<p><em>Examples:</em><ul class=simple><li><p><a class="reference external"href=./examples/tsp_rls_py.html>apply a randomized local search to one TSP instance</a><li><p><a class="reference external"href=./examples/tsp_special_algorithms_py.html>apply a some FFA-based algorithms to one TSP instance</a></ul><p>Important work on this code has been contributed by Mr. Tianyu LIANG (梁天宇), <a class="reference external"href=mailto:liangty%40stu.hfuu.edu.cn>liangty<span>@</span>stu<span>.</span>hfuu<span>.</span>edu<span>.</span>cn</a> a Master’s student at the Institute of Applied Optimization (应用优化研究所) of the School of Artificial Intelligence and Big Data (人工智能与大数据学院) at Hefei University (合肥学院) in Hefei, Anhui, China (中国安徽省合肥市) under the supervision of Prof. Dr. Thomas Weise (汤卫思教授).<p>The Traveling Tournament Problem (<a class="reference external"href=#the-traveling-tournament-problem-ttp>TTP</a>) is related to the TTP.</section><section id=dynamic-controller-synthesis><h2>3.3. Dynamic Controller Synthesis<a title="Link to this heading"class=headerlink href=#dynamic-controller-synthesis>¶</a></h2><p>Another interesting example for optimization is the synthesis of <a class="reference external"href=./moptipyapps.dynamic_control.html>active controllers for dynamic systems</a>. Dynamic systems have a state that changes over time based on some laws. These laws may be expressed as ordinary differential equations, for example. The classical <a class="reference external"href=./moptipyapps.dynamic_control.systems.html#module-moptipyapps.dynamic_control.systems.stuart_landau>Stuart-Landau system</a>, for instance, represents an object whose coordinates on a two-dimensional plane change as follows:<div class="highlight-default notranslate"><div class=highlight><pre><span></span>sigma = 0.1 - x² - y²
dx/dt = sigma * x - y
dy/dt = sigma * y + x
</pre></div></div><p>Regardless on which <code class="docutils literal notranslate"><span class=pre>(x,</span> <span class=pre>y)</span></code> the object initially starts, it tends to move to a circular rotation path centered around the origin with radius <code class="docutils literal notranslate"><span class=pre>sqrt(0.1)</span></code>. Now we try to create a controller <code class="docutils literal notranslate"><span class=pre>ctrl</span></code> for such a system that moves the object from this periodic circular path into a fixed and stable location. The controller <code class="docutils literal notranslate"><span class=pre>ctrl</span></code> receives the current state, i.e., the object location, as input and can influence the system as follows:<div class="highlight-default notranslate"><div class=highlight><pre><span></span>sigma = 0.1 - x² - y²
c = ctrl(x, y)
dx/dt = sigma * x - y
dy/dt = sigma * y + x + c
</pre></div></div><p>What we try to find is the controller which can bring move object to the origin <code class="docutils literal notranslate"><span class=pre>(0,</span> <span class=pre>0)</span></code> as quickly as possible while expending the least amount of force, i.e., having the smallest aggregated <code class="docutils literal notranslate"><span class=pre>c</span></code> values over time.</section><section id=the-traveling-tournament-problem-ttp><h2>3.4. The Traveling Tournament Problem (TTP)<a title="Link to this heading"class=headerlink href=#the-traveling-tournament-problem-ttp>¶</a></h2><p>In the package <a class="reference external"href=./moptipyapps.ttp.html#module-moptipyapps.ttp><code class="docutils literal notranslate"><span class=pre>moptipyapps.ttp</span></code></a>, we provide a set of classes and tools to explore the <em>Traveling Tournament Problem (TTP)</em>. In a TTP, we have an even number of <code class="docutils literal notranslate"><span class=pre>n</span></code> teams. Each team plays a tournament against every other team. If the tournament is a single round-robin tournament, each team plays exactly once against every other team. In the more common double round-robin tournament, each team plays twice against every other team — once at home and once at the place of the other team. A tournament takes <code class="docutils literal notranslate"><span class=pre>(n</span> <span class=pre>-</span> <span class=pre>1)</span> <span class=pre>*</span> <span class=pre>rounds</span></code> days in total, where <code class="docutils literal notranslate"><span class=pre>rounds</span> <span class=pre>=</span> <span class=pre>2</span></code> for double round-robin. Now additionally to the basic constraints dictated by logic (if team <code class="docutils literal notranslate"><span class=pre>A</span></code> plays at home against team <code class="docutils literal notranslate"><span class=pre>B</span></code> on day <code class="docutils literal notranslate"><span class=pre>d</span></code>, then team <code class="docutils literal notranslate"><span class=pre>B</span></code> has an “away” game against team <code class="docutils literal notranslate"><span class=pre>A</span></code> on that day <code class="docutils literal notranslate"><span class=pre>d</span></code> and so on), there are also additional constraints. For instance, no team should play a continuous streak of home (or away) games longer than <code class="docutils literal notranslate"><span class=pre>m</span></code> days, where <code class="docutils literal notranslate"><span class=pre>m</span></code> usually is <code class="docutils literal notranslate"><span class=pre>m</span> <span class=pre>=</span> <span class=pre>3</span></code>. Also, if teams <code class="docutils literal notranslate"><span class=pre>A</span></code> and <code class="docutils literal notranslate"><span class=pre>B</span></code> play against each other, then there must be at least <code class="docutils literal notranslate"><span class=pre>p</span></code> games in between before they play each other again, usually with <code class="docutils literal notranslate"><span class=pre>p</span> <span class=pre>=</span> <span class=pre>1</span></code>.<p>Now the first hurdle is to find a game plan that has <code class="docutils literal notranslate"><span class=pre>n</span> <span class=pre>/</span> <span class=pre>2</span></code> games on each day (since there are <code class="docutils literal notranslate"><span class=pre>n</span></code> teams and each plays against one other team) that satisfies the above constraints. The second problem is that this is not all: For each TTP, a distance matrix is defined, very much like for the <a class="reference external"href=#the-traveling-salesperson-problem-tsp>TSP</a>. The goal is to find a feasible game schedule where the overall travel distances are minimal.<p><em>Examples:</em><ul class=simple><li><p><a class="reference external"href=./examples/ttp_example_experiment_rls_rs_py.html>apply a local search to find a feasible TTP plan</a><li><p><a class="reference external"href=./examples/ttp_example_experiment_mo_py.html>tackle the TTP in a multi-objective manner</a></ul></section><section id=the-quadratic-assignment-problem-qap><h2>3.5. The Quadratic Assignment Problem (QAP)<a title="Link to this heading"class=headerlink href=#the-quadratic-assignment-problem-qap>¶</a></h2><p>In the package <a class="reference external"href=./moptipyapps.qap.html#module-moptipyapps.qap><code class="docutils literal notranslate"><span class=pre>moptipyapps.qap</span></code></a>, we implement some utilities to play with the Quadratic Assignment Problem (QAP). The QAP is one of the very classical problems from Operations Research. Imagine you are planning the layout for a factory. The goal is to assign <code class="docutils literal notranslate"><span class=pre>n</span></code> facilities (say, machines or workshops) to <code class="docutils literal notranslate"><span class=pre>n</span></code> locations. Now between the facilities, there exists a flow of goods. The output of one facility may be the input of another one and vice versa. The amount of stuff to be transported is likely to be different between different facilities. Between some facilities, a lot of things may need to be transport. Between others, there could be no exchange of material or only very little. The available locations also have different distances among each other. Some locations are closer, some are farther from each other. The goal is to find an assignment of facilities to locations such that the overall sum of the product of flow and distance for each facility pair gets minimized. To this end, solutions can be represented as permutations of facilities determining the order in which they are placed on the locations <code class="docutils literal notranslate"><span class=pre>1</span></code> to <code class="docutils literal notranslate"><span class=pre>n</span></code>.<p><em>Examples:</em><ul class=simple><li><p>See <a class="reference external"href=#one-dimensional-ordering>one-dimensional ordering</a><li><p><a class="reference external"href=./examples/qap_example_experiment_rls_rs_py.html>run a QAP experiment with RLS and random sampling</a></ul></section><section id=one-dimensional-ordering><h2>3.6. One-Dimensional Ordering<a title="Link to this heading"class=headerlink href=#one-dimensional-ordering>¶</a></h2><p>In the package <a class="reference external"href=./moptipyapps.order1d.html#module-moptipyapps.order1d><code class="docutils literal notranslate"><span class=pre>moptipyapps.order1d</span></code></a>, we implement what I would like to call the “one-dimensional ordering problem”. Imagine that you have <code class="docutils literal notranslate"><span class=pre>n</span></code> objects and you only know the distances between them. You want to arrange these objects on one axis, e.g., along the horizontal (<code class="docutils literal notranslate"><span class=pre>x</span></code>) axis, i.e., in a one-dimensional space. Now what you care about is to reflect the neighborhood structure among the objects (as defined by the distance matrix that you got) to the one-dimensional space. So the closest neighbor of a given object based on the distance matrix should also be the closest neighbor on the one-dimensional axis.<p>The goal of solving this problem is thus to arrange the <code class="docutils literal notranslate"><span class=pre>n</span></code> objects on a 1-dimensional (e.g., horizontal) axis given a distance matrix describing (maybe derived from their location in a potentially high-dimensional or unstructured space). The objects should be arranged in such a way that, for each object,<ul class=simple><li><p>the nearest neighbors on the 1-dimensional axis are also the nearest neighbors in the original space (according to the distance matrix provided),<li><p>the second nearest neighbors on the 1-dimensional axis are also the second nearest neighbors in the original space (according to the distance matrix provided),<li><p>the third nearest neighbors on the 1-dimensional axis are also the third nearest neighbors in the original space (according to the distance matrix provided),<li><p>and so on; with (quadratically) decreasing weights of neighbor distance ranks.</ul><p>The original distances be limited to integers for the sake of simplicity, but we may use floats as well if we want to. Either way, we do not care about the actual precise distances (e.g., something like “0.001”) between the objects on either the one-dimensional nor the original space. Only about the distance ranks, i.e., about “2nd nearest neighbor,” but not “0.012 distance units away.” The solutions of this problem are thus permutations (orders) of the objects. Of course, if we really want to plot the objects, such a permutation can easily be translated to <code class="docutils literal notranslate"><span class=pre>x</span></code>-coordinates, say, by dividing the index of an object by the number of objects, which nets values in <code class="docutils literal notranslate"><span class=pre>[0,1]</span></code>. But basically, we reduce the task to finding permutations of objects that reflect the neighbor structure of the original space as closely as possible.<p>If such a problem is solved correctly, then the arrangement on the one-dimensional axis should properly reflect the arrangement of the objects in the original space. Of course, solving this problem exactly may not actually be possible, since an object on a one-dimensional axis may either have exactly two <code class="docutils literal notranslate"><span class=pre>i</span></code>-nearest-neighbors (if it is at least <code class="docutils literal notranslate"><span class=pre>i</span></code> slots away from either end of the permutation) or exactly <code class="docutils literal notranslate"><span class=pre>1</span></code> such neighbor, if it is closer that <code class="docutils literal notranslate"><span class=pre>i</span></code> units. The object directly at the start of the permutation has only 1 nearest neighbor (the object that comes next). That next object, however, has two, namely the first object and the third object. In the original space where the objects come from, however, there may be any number of “nearest neighbors.” Imagine a two-dimensional space where one object sits at the center of a circle of other objects. Then all other objects are its nearest neighbors, whereas an object on the circle either has exactly two nearest neighbors or, maybe, in the odd situation that the radius equals a multiple of the distance to the neighbors on the circle, three. Such a structure cannot be represented exactly in one dimension.<p>But that’s OK. Because we mainly do this for visualization purposes anyway.<p><em>Examples:</em><ul class=simple><li><p><a class="reference external"href=./examples/order1_from_dat_py.html>use one-dimensional ordering to for search trajectory charts</a></ul></section></section><section id=unit-tests-and-static-analysis><h1>4. Unit Tests and Static Analysis<a title="Link to this heading"class=headerlink href=#unit-tests-and-static-analysis>¶</a></h1><p>When developing and applying randomized algorithms, proper testing and checking of the source code is of utmost importance. If we apply a randomized metaheuristic to an optimization problem, then we usually do not which solution quality we can achieve. Therefore, we can usually not know whether we have implemented the algorithm correctly. In other words, detecting bugs is very hard. Unfortunately, this holds also for the components of the algorithms, such as the search operators, especially if they are randomized as well. A bug may lead to worse results and we might not even notice that the worse result quality is caused by the bug. We may think that the algorithm is just not working well on the problem.<p>Therefore, we need to test all components of the algorithm as far as we can. We can try check, for example, if a randomized nullary search operator indeed creates different solutions when invoked several times. We can try to check whether an algorithm fails with an exception. We can try to check whether the search operators create valid solutions and whether the algorithm passes valid solutions to the objective function. We can try to whether an objective function produces finite objective values and if bounds are specified for the objective values, we can check whether they indeed fall within these bounds. Now we cannot prove that there are no such bugs, due to the randomization. But by testing a few hundred times, we can at least detect very obvious and pathological bugs.<p>To ease such testing for you, we provide a set of tools for testing implemented algorithms, spaces, and operators in the package <a class="reference external"href=./moptipyapps.tests.html>moptipyapps.tests</a>. Here, you can find functions where you pass in instances of your implemented components and they are checked for compliance with the <a class="reference external"href=https://thomasweise.github.io/moptipy/moptipy.api.html>moptipy API</a> and the problem setups defined in <code class="docutils literal notranslate"><span class=pre>moptipyapps</span></code>. In other words, if you go and implement your own algorithms, operators, and optimization problems, you can use our pre-defined unit tests to give them a thorough check before using them in production. Again, such tests cannot prove the absence of bugs. But they can at least give you a fair shot to detect pathological errors before wasting serious experimentation time.<p>We also try to extensively test our own code, see the coverage report of <a class="reference external"href=https://thomasweise.github.io/moptipy/tc/index.html><code class="docutils literal notranslate"><span class=pre>moptipy</span></code></a> and <a class="reference external"href=./tc/index.html><code class="docutils literal notranslate"><span class=pre>moptipyapps</span></code></a>.<p>Another way to try to improve and maintain code quality is to use static code analysis and type hints where possible and reasonable. A static analysis tool can inform you about, e.g., unused variables, which often result from a coding error. It can tell you if the types of expressions do not match, which usually indicates a coding error, too. It can tell you if you perform some security-wise unsafe operations (which is less often a problem in optimization, but it does not hurt to check). Code analysis tools can also help you to enforce best practices, which are good for performance, readability, and maintainability. They can push you to properly format and document your code, which, too, improve readability, maintainability, and usability. They even can detect a set of well-known and frequently-occurring bugs. We therefore also run a variety of such tools on our code base, including (in alphabetical order):<ul class=simple><li><p><a class="reference external"href=https://pypi.org/project/autoflake/><code class="docutils literal notranslate"><span class=pre>autoflake</span></code></a>, a tool for finding unused imports and variables<li><p><a class="reference external"href=https://pypi.org/project/bandit/><code class="docutils literal notranslate"><span class=pre>bandit</span></code></a>, a linter for finding security issues<li><p><a class="reference external"href=https://pypi.org/project/dodgy/><code class="docutils literal notranslate"><span class=pre>dodgy</span></code></a>, for checking for dodgy looking values in the code<li><p><a class="reference external"href=https://pypi.org/project/flake8/><code class="docutils literal notranslate"><span class=pre>flake8</span></code></a>, a collection of linters<li><p><a class="reference external"href=http://pypi.org/project/flake8-bugbear><code class="docutils literal notranslate"><span class=pre>flake8-bugbear</span></code></a>, for finding common bugs<li><p><a class="reference external"href=http://pypi.org/project/flake8-eradicate><code class="docutils literal notranslate"><span class=pre>flake8-eradicate</span></code></a>, for finding commented-out code<li><p><a class="reference external"href=http://pypi.org/project/flake8-use-fstring><code class="docutils literal notranslate"><span class=pre>flake8-use-fstring</span></code></a>, for checking the correct use of f-strings<li><p><a class="reference external"href=https://pypi.org/project/mypy/><code class="docutils literal notranslate"><span class=pre>mypy</span></code></a>, for checking types and type annotations<li><p><a class="reference external"href=https://pypi.org/project/pycodestyle/><code class="docutils literal notranslate"><span class=pre>pycodestyle</span></code></a>, for checking the formatting and coding style of the source<li><p><a class="reference external"href=https://pypi.org/project/pydocstyle/><code class="docutils literal notranslate"><span class=pre>pydocstyle</span></code></a>, for checking the format of the docstrings<li><p><a class="reference external"href=https://pypi.org/project/pyflakes/><code class="docutils literal notranslate"><span class=pre>pyflakes</span></code></a>, for detecting some errors in the code<li><p><a class="reference external"href=https://pypi.org/project/pylint/><code class="docutils literal notranslate"><span class=pre>pylint</span></code></a>, another static analysis tool<li><p><a class="reference external"href=https://pypi.org/project/pyroma/><code class="docutils literal notranslate"><span class=pre>pyroma</span></code></a>, for checking whether the code complies with various best practices<li><p><a class="reference external"href=https://pypi.org/project/ruff/><code class="docutils literal notranslate"><span class=pre>ruff</span></code></a>, a static analysis tool checking a wide range of coding conventions<li><p><a class="reference external"href=https://pypi.org/project/semgrep/><code class="docutils literal notranslate"><span class=pre>semgrep</span></code></a>, another static analyzer for finding bugs and problems<li><p><a class="reference external"href=https://pypi.org/project/tryceratops/><code class="docutils literal notranslate"><span class=pre>tryceratops</span></code></a>, for checking against exception handling anti-patterns<li><p><a class="reference external"href=https://pypi.org/project/unimport/><code class="docutils literal notranslate"><span class=pre>unimport</span></code></a>, for checking against unused import statements<li><p><a class="reference external"href=https://pypi.org/project/vulture/><code class="docutils literal notranslate"><span class=pre>vulture</span></code></a>, for finding dead code</ul><p>On git pushes, GitHub also automatically runs <a class="reference external"href=https://codeql.github.com/>CodeQL</a> to check for common vulnerabilities and coding errors. We also turned on GitHub’s <a class="reference external"href=https://docs.github.com/en/code-security/security-advisories/repository-security-advisories/configuring-private-vulnerability-reporting-for-a-repository>private vulnerability reporting</a> and the Dependabot <a class="reference external"href=https://docs.github.com/en/code-security/dependabot/dependabot-alerts/configuring-dependabot-alerts>vulnerability</a> and <a class="reference external"href=https://docs.github.com/en/code-security/dependabot/dependabot-security-updates/configuring-dependabot-security-updates>security</a> alerts.<p>Using all of these tools increases the build time. However, combined with thorough unit testing and documentation, it should help to prevent bugs, to improve readability, maintainability, and usability of the code. It does not matter whether we are doing research or try to solve practical problems in the industry — we should always strive to make good software with high code quality.<p>Often, researchers in particular think that hacking something together that works is enough, that documentation is unimportant, that code style best practices can be ignored, and so on. And then they wonder why they cannot understand their own code a few years down the line (at least, this happened to me in the past…). Or why no one can use their code to build atop of their research (which is the normal case for me).<p>Improving code quality can <em>never</em> come later. We <em>always</em> must maintain high coding and documentation standards from the very beginning. While <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> may still be far from achieving these goals, at least we try to get there.<p>Anyway, you can find our full build script running all the tests, doing all the static analyses, creating the documentation, and creating and packaging the distribution files in the repository, too. Besides the <a class="reference external"href=./requirements-dev_txt.html>basic <code class="docutils literal notranslate"><span class=pre>moptipyapps</span></code> dependencies</a>, it requires <a class="reference external"href=./requirements-dev_txt.html>a set of additional dependencies</a>. These are all automatically installed during the build procedure. The build only works under Linux.</section><section id=license><h1>5. License<a title="Link to this heading"class=headerlink href=#license>¶</a></h1><p><a class="reference external"href=./><code class="docutils literal notranslate"><span class=pre>moptipyapps</span></code></a> is a library for implementing, using, and experimenting with metaheuristic optimization algorithms. Our project is developed for scientific, educational, and industrial applications.<p>Copyright (C) 2023 <a class="reference external"href=http://iao.hfuu.edu.cn/5>Thomas Weise</a> (汤卫思教授)<p>Dr. Thomas Weise (see <a class="reference external"href=#contact>Contact</a>) holds the copyright of this package <em>except</em> for the data of the benchmark sets we imported from other sources. <code class="docutils literal notranslate"><span class=pre>moptipyapps</span></code> is provided to the public as open source software under the <a class="reference external"href=./LICENSE.html>GNU GENERAL PUBLIC LICENSE, Version 3, 29 June 2007</a>. Terms for other licenses, e.g., for specific industrial applications, can be negotiated with Dr. Thomas Weise (who can be reached via the <a class="reference external"href=#contact>contact information</a> below).<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <a class="reference external"href=https://www.gnu.org/licenses/>https://www.gnu.org/licenses/</a>.<p>Please visit the <a class="reference external"href=./CONTRIBUTING_md.html>contributions guidelines</a> for <code class="docutils literal notranslate"><span class=pre>moptipy</span></code> if you would like to contribute to our package. If you have any concerns regarding security, please visit our <a class="reference external"href=./SECURITY_md.html>security policy</a>.<section id=exceptions><h2>5.1. Exceptions<a title="Link to this heading"class=headerlink href=#exceptions>¶</a></h2><ul class=simple><li><p>Most of the included benchmark instance data of the <a class="reference external"href=#two-dimensional-bin-packing-problem>two-dimensional bin packing problem</a> is taken from <a class="reference external"href=https://site.unibo.it/operations-research/en/research/2dpacklib>2DPackLib</a>. It has been stored in a more size-efficient way and some unnecessary information has been stripped from it (as we really only need the raw bin packing data). Nevertheless, the copyright of the original data lies with the authors <a class="reference external"href=https://site.unibo.it/operations-research/en/research/2dpacklib>2DPackLib</a> or the original authors of the datasets used by them.<li><p>The included benchmark instances for the <a class="reference external"href=#the-traveling-salesperson-problem-tsp>Traveling Salesperson Problem</a> are taken from <a class="reference external"href=http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/>TSPLib</a>. The copyright of the original data lies with Gerhard Reinelt, the original author of TSPLib, or the original authors of the datasets used by him.<li><p>The included benchmark instances for the <a class="reference external"href=./#the-traveling-tournament-problem-ttp>Traveling Tournament Problem</a> are taken from <a class="reference external"href=https://robinxval.ugent.be/RobinX/travelRepo.php>RobinX</a>. The copyright of the original data lies with the <a class="reference external"href=https://robinxval.ugent.be/RobinX/contact.php>authors</a> of the dataset, presumably D. Van Bulck, D. Goossens, J. Schönberger, and M. Guajardo.<li><p>The included benchmark instances for the Quadratic Assignment Problem are taken from QAPLib, which is available at <a class="reference external"href=https://qaplib.mgi.polymtl.ca>https://qaplib.mgi.polymtl.ca</a> and <a class="reference external"href=https://coral.ise.lehigh.edu/data-sets/qaplib>https://coral.ise.lehigh.edu/data-sets/qaplib</a>. The copyright of the original repository lies with R.E. Burkard, E. Çela, S.E. Karisch and F. Rendl as well as Peter Hahn and Miguel Anjos.</ul></section></section><section id=contact><h1>6. Contact<a title="Link to this heading"class=headerlink href=#contact>¶</a></h1><p>If you have any questions or suggestions, please contact Prof. Dr. <a class="reference external"href=http://iao.hfuu.edu.cn/5>Thomas Weise</a> (汤卫思教授) of the Institute of Applied Optimization (应用优化研究所, <a class="reference external"href=http://iao.hfuu.edu.cn>IAO</a>) of the School of Artificial Intelligence and Big Data (<a class="reference external"href=http://www.hfuu.edu.cn/aibd/>人工智能与大数据学院</a>) at <a class="reference external"href=http://www.hfuu.edu.cn/english/>Hefei University</a> (<a class="reference external"href=http://www.hfuu.edu.cn/>合肥大学</a>) in Hefei, Anhui, China (中国安徽省合肥市) via email to <a class="reference external"href=mailto:tweise%40hfuu.edu.cn>tweise<span>@</span>hfuu<span>.</span>edu<span>.</span>cn</a> with CC to <a class="reference external"href=mailto:tweise%40ustc.edu.cn>tweise<span>@</span>ustc<span>.</span>edu<span>.</span>cn</a>.</section><div class=clearer></div></div></div></div><div aria-label=Main class=sphinxsidebar role=navigation><div class=sphinxsidebarwrapper><div><h3><a href=index.html>Table of Contents</a></h3><ul><li><a class="reference internal"href=#>1. Introduction</a><li><a class="reference internal"href=#installation>2. Installation</a><li><a class="reference internal"href=#applications>3. Applications</a><ul><li><a class="reference internal"href=#two-dimensional-bin-packing-problem>3.1. Two-Dimensional Bin Packing Problem</a><li><a class="reference internal"href=#the-traveling-salesperson-problem-tsp>3.2. The Traveling Salesperson Problem (TSP)</a><li><a class="reference internal"href=#dynamic-controller-synthesis>3.3. Dynamic Controller Synthesis</a><li><a class="reference internal"href=#the-traveling-tournament-problem-ttp>3.4. The Traveling Tournament Problem (TTP)</a><li><a class="reference internal"href=#the-quadratic-assignment-problem-qap>3.5. The Quadratic Assignment Problem (QAP)</a><li><a class="reference internal"href=#one-dimensional-ordering>3.6. One-Dimensional Ordering</a></ul><li><a class="reference internal"href=#unit-tests-and-static-analysis>4. Unit Tests and Static Analysis</a><li><a class="reference internal"href=#license>5. License</a><ul><li><a class="reference internal"href=#exceptions>5.1. Exceptions</a></ul><li><a class="reference internal"href=#contact>6. Contact</a></ul></div><div aria-label="source link"role=note><h3>This Page</h3><ul class=this-page-menu><li><a href=_sources/README.md.txt rel=nofollow>Show Source</a></ul></div><search id=searchbox role=search style=display:none> <h3 id=searchlabel>Quick search</h3> <div class=searchformwrapper><form action=search.html class=search><input aria-labelledby=searchlabel autocapitalize=off autocomplete=off autocorrect=off name=q spellcheck=false><input type=submit value=Go></form></div> </search><script>document.getElementById(`searchbox`).style.display=`block`</script></div></div><div class=clearer></div></div><div aria-label=Related class=related role=navigation><h3>Navigation</h3><ul><li class=right style=margin-right:10px><a title="General Index"href=genindex.html>index</a><li class=right><a title="Python Module Index"href=py-modindex.html>modules</a> |<li class="nav-item nav-item-0"><a href=index.html>moptipyapps 0.8.68 documentation</a> »<li class="nav-item nav-item-this"><a href>1. Introduction</a></ul></div><div class=footer role=contentinfo>© Copyright 2023-2025, Thomas Weise.</div>
